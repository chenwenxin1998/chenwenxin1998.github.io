{"title":"算法练习1","slug":"算法练习1","date":"2018-10-29T03:34:10.057Z","updated":"2018-10-30T09:46:08.334Z","comments":true,"path":"api/articles/算法练习1.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>给定一个整数数组（下标由 0 到 n-1，其中 n 表示数组的规模），以及一个查询列表。每一个查询列表有两个整数 [start, end] 。 对于每个查询，计算出数组中从下标 start 到 end 之间的数的总和，并返回在结果列表中。</p>\n<h2 id=\"样例\"><a href=\"#样例\" class=\"headerlink\" title=\"样例\"></a>样例</h2><p>对于数组 [1,2,7,8,5]，查询[(1,2),(0,4),(2,4)], 返回 [9,23,20].</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code>//Definition of Interval:\nclasss Interval {\n    int start, end;\n    nterval(int start, int end) {\n        this-&gt;start = start;\n        this-&gt;end = end;\n  }\n  }\n\n\nclass Solution {\n/*public:\n/**\n * @param A: An integer list\n * @param queries: An query list\n * @return: The result list\n  */\nvector&lt;long long&gt; intervalSum(vector&lt;int&gt; &amp;A,vector&lt;Interval&gt; &amp;queries) {\n// write your code here\nvector&lt;long long&gt; x;\n\nfor(int i = 0;i&lt;queries.size();i++){\nlong long temp = 0;\nfor(int j = queries[i].start;j&lt;= queries[i].end;j++){\ntemp+=A[j];\n}\nx.push_back(temp);\n}\nreturn x;\n}\n</code></pre><h2 id=\"提升\"><a href=\"#提升\" class=\"headerlink\" title=\"提升\"></a>提升</h2><p>class SegmentTree {</p>\n<p>public:<code></code></p>\n<pre><code>SegmentTree *left, *right;\nint start, end;`\nlong long sum;\n\nSegmentTree(int start, int end, int sum=0): left(NULL), right(NULL), start(start), end(end), sum(sum) {};\n\nstatic SegmentTree *build(int start, int end, vector&lt;int&gt; &amp;a) {\n    if (start &gt; end)\n        return NULL;\n\n    SegmentTree * node = new SegmentTree(start, end, a[start]);\n    if (start == end) \n        return node;\n\n    int mid = (start + end) / 2;\n    node-&gt;left = build(start, mid, a);\n    node-&gt;right = build(mid+1, end, a);\n    node-&gt;sum = node-&gt;left-&gt;sum + node-&gt;right-&gt;sum;\n\n    return node;\n}\n\nstatic long long query(SegmentTree *root, int start, int end) {\n    if (start &lt;= root-&gt;start &amp;&amp;  root-&gt;end &lt;= end) {\n        return root-&gt;sum;\n    }\n\n    if (root-&gt;left-&gt;end &gt;= end) {\n        return query(root-&gt;left, start, end);\n    }\n    if (root-&gt;right-&gt;start &lt;= start) {\n        return query(root-&gt;right, start, end);\n    }\n\n    long long leftsum = query(root-&gt;left, start, root-&gt;left-&gt;end);\n    long long rightsum = query(root-&gt;right, root-&gt;right-&gt;start, end);\n    return leftsum + rightsum;\n}\n</code></pre><p>};</p>\n<p><code>class Solution {</code> </p>\n<pre><code>public:\n\n/**\n *@param A, queries: Given an integer array and an query list\n\n *@return: The result list\n */\n\nvector&lt;long longintervalSum(vector&lt;int&amp;A, vector&lt;Interval&amp;queries) {\n\n    // write your code here\n\n    SegmentTree * root = SegmentTree::build(0, A.size()-1, A);\n    vector&lt;long longresult;\n\n    int len = queries.size();\n    for (int i = 0; i &lt; len; ++i)\n        result.push_back(SegmentTree::query(root, queries[i].start, queries[i].end));\n\n    return result;\n}\n</code></pre><p>};<code></code></p>\n","categories":[],"tags":[]}