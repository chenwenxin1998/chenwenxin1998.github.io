{"total":3,"pageSize":10,"pageCount":1,"data":[{"title":"久源杯参赛过程记录（1）","slug":"久源杯参赛过程记录（1）","date":"2018-11-04T03:57:44.144Z","updated":"2018-11-04T03:57:44.279Z","comments":true,"path":"api/articles/久源杯参赛过程记录（1）.json","excerpt":"","keywords":null,"cover":"https://github.com/chenwenxin1998/MyPostImage/blob/1bbeea4edda48d70a07859f74b302e36601fe7bf/pic/Snipaste_2018-11-04_11-39-53.png?raw=true","content":"<h1 id=\"比赛简介\"><a href=\"#比赛简介\" class=\"headerlink\" title=\"比赛简介\"></a>比赛简介</h1><p><em>首先其实是我们学校的一个很简单的比赛，要求制作一个带有界面的核素实时查询的软件，输入原子序数，或者元素名称能够显示关于他的信息。\n</em></p>\n<h1 id=\"前期准备\"><a href=\"#前期准备\" class=\"headerlink\" title=\"前期准备\"></a>前期准备</h1><p>以前自学了python,但是基本上没有实用，趁这个比赛就正好拿python练手，希望能够更加熟悉他,总之不管结果如何，参与的过程中自己能学到东西就感到满足了。</p>\n<p><strong>语言 python3.7</strong></p>\n<p><strong>数据库：MySQL</strong></p>\n<p><strong>界面：pyQt5(Qt_Designer+eric6)</strong>（中文资料实在是太少，硬着头皮啃《QT5—PYTHON-GUI-PROGRAMMING-COOKBOOK》，写得不错，有兴趣的可以去看看）</p>\n<h1 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h1><p>代码会在比赛结束后分享。</p>\n<p>可以在我博客主页关注我们github,比赛结束后项目也会上传</p>\n<h2 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h2><p>简单的写了个窗口，建了个数据库<br><img src=\"https://github.com/chenwenxin1998/MyPostImage/blob/1bbeea4edda48d70a07859f74b302e36601fe7bf/pic/Snipaste_2018-11-04_11-39-53.png?raw=true\" alt=\"\"></p>\n<p>效果：<br><img src=\"https://github.com/chenwenxin1998/MyPostImage/blob/1bbeea4edda48d70a07859f74b302e36601fe7bf/pic/Snipaste_2018-11-04_11-41-10.png?raw=true\" alt=\"\"></p>\n","text":"比赛简介首先其实是我们学校的一个很简单的比赛，要求制作一个带有界面的核素实时查询的软件，输入原子序数，或者元素名称能够显示关于他的信息。前期准备以前自学了python,但是基本上没有实用，趁这个比赛就正好拿python练手，希望能够更加熟悉他,总之不管结果如何，参与的过程中自己能","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"算法练习1","slug":"算法练习1","date":"2018-10-29T03:34:10.057Z","updated":"2018-10-30T09:46:08.334Z","comments":true,"path":"api/articles/算法练习1.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>给定一个整数数组（下标由 0 到 n-1，其中 n 表示数组的规模），以及一个查询列表。每一个查询列表有两个整数 [start, end] 。 对于每个查询，计算出数组中从下标 start 到 end 之间的数的总和，并返回在结果列表中。</p>\n<h2 id=\"样例\"><a href=\"#样例\" class=\"headerlink\" title=\"样例\"></a>样例</h2><p>对于数组 [1,2,7,8,5]，查询[(1,2),(0,4),(2,4)], 返回 [9,23,20].</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code>//Definition of Interval:\nclasss Interval {\n    int start, end;\n    nterval(int start, int end) {\n        this-&gt;start = start;\n        this-&gt;end = end;\n  }\n  }\n\n\nclass Solution {\n/*public:\n/**\n * @param A: An integer list\n * @param queries: An query list\n * @return: The result list\n  */\nvector&lt;long long&gt; intervalSum(vector&lt;int&gt; &amp;A,vector&lt;Interval&gt; &amp;queries) {\n// write your code here\nvector&lt;long long&gt; x;\n\nfor(int i = 0;i&lt;queries.size();i++){\nlong long temp = 0;\nfor(int j = queries[i].start;j&lt;= queries[i].end;j++){\ntemp+=A[j];\n}\nx.push_back(temp);\n}\nreturn x;\n}\n</code></pre><h2 id=\"提升\"><a href=\"#提升\" class=\"headerlink\" title=\"提升\"></a>提升</h2><p>class SegmentTree {</p>\n<p>public:<code></code></p>\n<pre><code>SegmentTree *left, *right;\nint start, end;`\nlong long sum;\n\nSegmentTree(int start, int end, int sum=0): left(NULL), right(NULL), start(start), end(end), sum(sum) {};\n\nstatic SegmentTree *build(int start, int end, vector&lt;int&gt; &amp;a) {\n    if (start &gt; end)\n        return NULL;\n\n    SegmentTree * node = new SegmentTree(start, end, a[start]);\n    if (start == end) \n        return node;\n\n    int mid = (start + end) / 2;\n    node-&gt;left = build(start, mid, a);\n    node-&gt;right = build(mid+1, end, a);\n    node-&gt;sum = node-&gt;left-&gt;sum + node-&gt;right-&gt;sum;\n\n    return node;\n}\n\nstatic long long query(SegmentTree *root, int start, int end) {\n    if (start &lt;= root-&gt;start &amp;&amp;  root-&gt;end &lt;= end) {\n        return root-&gt;sum;\n    }\n\n    if (root-&gt;left-&gt;end &gt;= end) {\n        return query(root-&gt;left, start, end);\n    }\n    if (root-&gt;right-&gt;start &lt;= start) {\n        return query(root-&gt;right, start, end);\n    }\n\n    long long leftsum = query(root-&gt;left, start, root-&gt;left-&gt;end);\n    long long rightsum = query(root-&gt;right, root-&gt;right-&gt;start, end);\n    return leftsum + rightsum;\n}\n</code></pre><p>};</p>\n<p><code>class Solution {</code> </p>\n<pre><code>public:\n\n/**\n *@param A, queries: Given an integer array and an query list\n\n *@return: The result list\n */\n\nvector&lt;long longintervalSum(vector&lt;int&amp;A, vector&lt;Interval&amp;queries) {\n\n    // write your code here\n\n    SegmentTree * root = SegmentTree::build(0, A.size()-1, A);\n    vector&lt;long longresult;\n\n    int len = queries.size();\n    for (int i = 0; i &lt; len; ++i)\n        result.push_back(SegmentTree::query(root, queries[i].start, queries[i].end));\n\n    return result;\n}\n</code></pre><p>};<code></code></p>\n","text":"描述给定一个整数数组（下标由 0 到 n-1，其中 n 表示数组的规模），以及一个查询列表。每一个查询列表有两个整数 [start, end] 。 对于每个查询，计算出数组中从下标 start 到 end 之间的数的总和，并返回在结果列表中。样例对于数组 [1,2,7,8,5]，","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"从树的遍历理解递归","slug":"二叉树的遍历理解递归","date":"2018-10-28T11:31:58.147Z","updated":"2018-10-28T12:28:15.624Z","comments":true,"path":"api/articles/二叉树的遍历理解递归.json","excerpt":"","keywords":null,"cover":"https://raw.githubusercontent.com/chenwenxin1998/MyPostImage/master/pic/%E9%80%92%E5%BD%921.bmp","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void firstTra(Tree *T)&#123;  </span><br><span class=\"line\">\tif(T)&#123;  </span><br><span class=\"line\">\t\tcout&lt;&lt;T-&gt;data;  </span><br><span class=\"line\">\t\tfirstTra(T-&gt;leftTree);  </span><br><span class=\"line\">\t\tfirstTra(T-&gt;rightTree);  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/chenwenxin1998/MyPostImage/master/pic/%E9%80%92%E5%BD%921.bmp\" alt=\"\"><br>            图1.只有左子树的简单二叉树</p>\n<p><img src=\"https://raw.githubusercontent.com/chenwenxin1998/MyPostImage/master/pic/%E9%80%92%E5%BD%922.bmp\" alt=\"\"><br>           图2.递归遍历执行的顺序 </p>\n<p><strong>首先我们应该了解程序的执行是逐句的，也就是说当上一条语句运行结束后才会执行下一条语句.  </strong></p>\n<p>递归：我们可以将它拆分为两个字单独来看：</p>\n<p>递：向下传递；归：往回运行</p>\n<p>在对树的遍历中，使用语句简洁的递归算法（先序遍历）：当当前结点不为空时，调用该函数对其左子节点进行遍历，如果仍不为空，则继续调用，一直到所访问的结点为空，即一直到firstTra（D-&gt;leftTree）。（这里可以理解为向下传递也就是递归的“递”）即如图所示。<br>当D-&gt;leftTree为NULL时，返回第四步然后执行第四步的剩下的语句，当第四步end后，返回第三步，当第三步执行完成后，也就是第二步的firstTra()执行完毕。然后执行第二步后面的语句。最后返回第一步。执行后面的语句。直到执行到第一个最先打开的的函数运行完毕。这里可以理解为“归”）。<br>这样对递归的理解就比较容易了。</p>\n<p>2018/10/28 20:17:45<br>-原创</p>\n","text":"1<br>2<br>3<br>4<br>5<br>6<br>7<br>void firstTra(Tree *T)&#123;  <br>\tif(T)&#123;  <br>\t\tcout&lt;&lt;T-&gt;data;  <br>\t\tfirstTra(T-&gt;leftT","link":"","raw":null,"photos":[],"categories":[],"tags":[]}]}