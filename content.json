{"meta":{"title":"Chen'Blog","subtitle":"keep warm!Keep true !","description":"a blog of a student majoring in cs!","author":"ChenWenxin","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"从树的遍历理解递归","slug":"二叉树的遍历理解递归","date":"2018-10-28T11:31:58.147Z","updated":"2018-10-28T12:28:15.624Z","comments":true,"path":"2018/10/28/二叉树的遍历理解递归/","link":"","permalink":"http://yoursite.com/2018/10/28/二叉树的遍历理解递归/","excerpt":"","text":"1234567void firstTra(Tree *T)&#123; if(T)&#123; cout&lt;&lt;T-&gt;data; firstTra(T-&gt;leftTree); firstTra(T-&gt;rightTree); &#125; &#125; 图1.只有左子树的简单二叉树 图2.递归遍历执行的顺序 首先我们应该了解程序的执行是逐句的，也就是说当上一条语句运行结束后才会执行下一条语句. 递归：我们可以将它拆分为两个字单独来看： 递：向下传递；归：往回运行 在对树的遍历中，使用语句简洁的递归算法（先序遍历）：当当前结点不为空时，调用该函数对其左子节点进行遍历，如果仍不为空，则继续调用，一直到所访问的结点为空，即一直到firstTra（D-&gt;leftTree）。（这里可以理解为向下传递也就是递归的“递”）即如图所示。当D-&gt;leftTree为NULL时，返回第四步然后执行第四步的剩下的语句，当第四步end后，返回第三步，当第三步执行完成后，也就是第二步的firstTra()执行完毕。然后执行第二步后面的语句。最后返回第一步。执行后面的语句。直到执行到第一个最先打开的的函数运行完毕。这里可以理解为“归”）。这样对递归的理解就比较容易了。 2018/10/28 20:17:45-原创","categories":[],"tags":[]}]}